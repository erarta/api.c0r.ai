"""
Model Manager for c0r.AI ML Service
Central management of all AI models and providers
"""

from typing import Dict, Optional, List, Any
import asyncio
from loguru import logger

from ..config.sota_config import ModelConfig, TaskType, ModelTier, SOTA_MODEL_CONFIGS, get_model_config
from ..config.environment_config import EnvironmentConfig
from ..providers.base_provider import BaseAIProvider, ModelResponse
from ..providers.openai_provider import OpenAIProvider


class ModelManager:
    """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ–Ω–µ–¥–∂–µ—Ä ML –º–æ–¥–µ–ª–µ–π"""
    
    def __init__(self):
        self.providers: Dict[str, BaseAIProvider] = {}
        self.initialized = False
        self._initialize_providers()
    
    def _initialize_providers(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"""
        logger.info("üöÄ Initializing ML model providers...")
        
        try:
            # OpenAI –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã
            if EnvironmentConfig.OPENAI_API_KEY:
                self._initialize_openai_providers()
            else:
                logger.warning("‚ö†Ô∏è OpenAI API key not found, skipping OpenAI providers")
            
            # TODO: –î–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã (Anthropic, Google)
            # if EnvironmentConfig.ANTHROPIC_API_KEY:
            #     self._initialize_anthropic_providers()
            
            self.initialized = True
            logger.info(f"‚úÖ Model Manager initialized with {len(self.providers)} providers")
            
            # –õ–æ–≥–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã
            for provider_key, provider in self.providers.items():
                logger.info(f"  - {provider_key}: {provider}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize Model Manager: {e}")
            raise
    
    def _initialize_openai_providers(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OpenAI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"""
        logger.info("üîß Initializing OpenAI providers...")
        
        for task_type in TaskType:
            task_configs = SOTA_MODEL_CONFIGS.get(task_type, {})
            
            for tier, config in task_configs.items():
                if config.provider == "openai":
                    try:
                        provider_key = f"{task_type.value}_{tier.value}_openai"
                        provider = OpenAIProvider(config)
                        self.providers[provider_key] = provider
                        logger.debug(f"  ‚úÖ {provider_key}: {config.name}")
                    except Exception as e:
                        logger.error(f"  ‚ùå Failed to initialize {provider_key}: {e}")
    
    async def generate_food_analysis(self,
                                   image_data: bytes,
                                   user_language: str,
                                   regional_context: Dict[str, Any],
                                   user_profile: Dict[str, Any],
                                   tier: ModelTier = None) -> ModelResponse:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –µ–¥—ã"""
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º tier –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π
        if tier is None:
            tier_name = EnvironmentConfig.DEFAULT_TIER.lower()
            tier = ModelTier(tier_name) if tier_name in [t.value for t in ModelTier] else ModelTier.SOTA
        
        logger.info(f"üçΩÔ∏è Generating food analysis with tier: {tier.value}")
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –º–æ–¥–µ–ª–∏
            config = get_model_config(TaskType.FOOD_ANALYSIS, tier)
            provider_key = f"{TaskType.FOOD_ANALYSIS.value}_{tier.value}_{config.provider}"
            
            if provider_key not in self.providers:
                logger.warning(f"‚ö†Ô∏è Provider {provider_key} not available, trying fallback...")
                return await self._try_fallback_analysis(image_data, user_language, regional_context, user_profile)
            
            provider = self.providers[provider_key]
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º PromptBuilder –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞
            from ...prompts.base.prompt_builder import PromptBuilder
            from ....modules.location.models import RegionalContext
            
            prompt_builder = PromptBuilder()
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º regional_context –≤ –æ–±—ä–µ–∫—Ç RegionalContext –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if regional_context and not isinstance(regional_context, RegionalContext):
                # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω dict
                from ....modules.location.models import RegionalContext
                regional_context_obj = RegionalContext(
                    region_code=regional_context.get('region_code', 'RU'),
                    cuisine_types=regional_context.get('cuisine_types', ['—Ä—É—Å—Å–∫–∞—è']),
                    common_products=regional_context.get('common_products', ['–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å', '–∫–∞–ø—É—Å—Ç–∞', '–º–æ—Ä–∫–æ–≤—å']),
                    cooking_methods=regional_context.get('cooking_methods', ['–≤–∞—Ä–∫–∞', '–∂–∞—Ä–∫–∞', '—Ç—É—à–µ–Ω–∏–µ']),
                    measurement_units=regional_context.get('measurement_units', 'metric'),
                    food_culture_notes=regional_context.get('food_culture_notes', '–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞—è —Ä—É—Å—Å–∫–∞—è –∫—É—Ö–Ω—è'),
                    seasonal_products=regional_context.get('seasonal_products', {})
                )
            else:
                regional_context_obj = regional_context
            
            # –°–æ–∑–¥–∞–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç —Å –º–æ—Ç–∏–≤–∞—Ü–∏–µ–π –∏ —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
            prompt = prompt_builder.build_food_analysis_prompt(
                user_language=user_language,
                regional_context=regional_context_obj,
                user_profile=user_profile or {},
                motivation_level="standard"
            )
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            logger.debug(f"üöÄ Using provider: {provider}")
            response = await provider.generate_with_retry(prompt, image_data)
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            if response.success:
                logger.info(f"‚úÖ Food analysis completed: {response.model_used}, tokens: {response.tokens_used}, cost: ${response.cost:.4f}")
            else:
                logger.error(f"‚ùå Food analysis failed: {response.error_message}")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Food analysis error: {e}")
            return ModelResponse(
                content="",
                model_used="error",
                provider="error",
                tokens_used=0,
                cost=0.0,
                response_time=0.0,
                success=False,
                error_message=str(e)
            )
    
    async def generate_triple_recipes(self,
                                    image_data: bytes,
                                    user_language: str,
                                    user_context: Dict[str, Any],
                                    regional_context: Dict[str, Any],
                                    tier: ModelTier = None) -> ModelResponse:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ—Ö —Ä–µ—Ü–µ–ø—Ç–æ–≤"""
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º tier
        if tier is None:
            tier_name = EnvironmentConfig.DEFAULT_TIER.lower()
            tier = ModelTier(tier_name) if tier_name in [t.value for t in ModelTier] else ModelTier.SOTA
        
        logger.info(f"üë®‚Äçüç≥ Generating triple recipes with tier: {tier.value}")
        
        try:
            config = get_model_config(TaskType.RECIPE_GENERATION, tier)
            provider_key = f"{TaskType.RECIPE_GENERATION.value}_{tier.value}_{config.provider}"
            
            if provider_key not in self.providers:
                logger.warning(f"‚ö†Ô∏è Provider {provider_key} not available, trying fallback...")
                return await self._try_fallback_recipes(image_data, user_language, user_context, regional_context)
            
            provider = self.providers[provider_key]
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º PromptBuilder –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ —Ä–µ—Ü–µ–ø—Ç–æ–≤
            from ...prompts.base.prompt_builder import PromptBuilder
            from ....modules.location.models import RegionalContext
            
            prompt_builder = PromptBuilder()
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º regional_context –≤ –æ–±—ä–µ–∫—Ç RegionalContext –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if regional_context and not isinstance(regional_context, RegionalContext):
                from ....modules.location.models import RegionalContext
                regional_context_obj = RegionalContext(
                    region_code=regional_context.get('region_code', 'RU'),
                    cuisine_types=regional_context.get('cuisine_types', ['—Ä—É—Å—Å–∫–∞—è']),
                    common_products=regional_context.get('common_products', ['–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å', '–∫–∞–ø—É—Å—Ç–∞', '–º–æ—Ä–∫–æ–≤—å']),
                    cooking_methods=regional_context.get('cooking_methods', ['–≤–∞—Ä–∫–∞', '–∂–∞—Ä–∫–∞', '—Ç—É—à–µ–Ω–∏–µ']),
                    measurement_units=regional_context.get('measurement_units', 'metric'),
                    food_culture_notes=regional_context.get('food_culture_notes', '–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞—è —Ä—É—Å—Å–∫–∞—è –∫—É—Ö–Ω—è'),
                    seasonal_products=regional_context.get('seasonal_products', {})
                )
            else:
                regional_context_obj = regional_context
            
            # –°–æ–∑–¥–∞–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ—Ü–µ–ø—Ç–æ–≤
            prompt = prompt_builder.build_recipe_generation_prompt(
                user_language=user_language,
                regional_context=regional_context_obj,
                user_profile=user_context or {},
                recipe_count=3
            )
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            logger.debug(f"üöÄ Using provider: {provider}")
            response = await provider.generate_with_retry(prompt, image_data)
            
            # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            if response.success:
                logger.info(f"‚úÖ Recipe generation completed: {response.model_used}, tokens: {response.tokens_used}, cost: ${response.cost:.4f}")
            else:
                logger.error(f"‚ùå Recipe generation failed: {response.error_message}")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Recipe generation error: {e}")
            return ModelResponse(
                content="",
                model_used="error",
                provider="error",
                tokens_used=0,
                cost=0.0,
                response_time=0.0,
                success=False,
                error_message=str(e)
            )
    
    async def _try_fallback_analysis(self,
                                   image_data: bytes,
                                   user_language: str,
                                   regional_context: Dict[str, Any],
                                   user_profile: Dict[str, Any]) -> ModelResponse:
        """–ü–æ–ø—ã—Ç–∫–∞ fallback –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –µ–¥—ã"""
        
        # –ü—Ä–æ–±—É–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
        fallback_order = [ModelTier.PREMIUM, ModelTier.STANDARD, ModelTier.BUDGET]
        
        for tier in fallback_order:
            try:
                config = get_model_config(TaskType.FOOD_ANALYSIS, tier)
                provider_key = f"{TaskType.FOOD_ANALYSIS.value}_{tier.value}_{config.provider}"
                
                if provider_key in self.providers:
                    logger.info(f"üîÑ Trying fallback with {provider_key}")
                    provider = self.providers[provider_key]
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º PromptBuilder –∏ –¥–ª—è fallback
                    from ...prompts.base.prompt_builder import PromptBuilder
                    from ....modules.location.models import RegionalContext
                    
                    prompt_builder = PromptBuilder()
                    
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º regional_context –≤ –æ–±—ä–µ–∫—Ç RegionalContext –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    if regional_context and not isinstance(regional_context, RegionalContext):
                        from ....modules.location.models import RegionalContext
                        regional_context_obj = RegionalContext(
                            region_code=regional_context.get('region_code', 'RU'),
                            cuisine_types=regional_context.get('cuisine_types', ['—Ä—É—Å—Å–∫–∞—è']),
                            common_products=regional_context.get('common_products', ['–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å', '–∫–∞–ø—É—Å—Ç–∞', '–º–æ—Ä–∫–æ–≤—å']),
                            cooking_methods=regional_context.get('cooking_methods', ['–≤–∞—Ä–∫–∞', '–∂–∞—Ä–∫–∞', '—Ç—É—à–µ–Ω–∏–µ']),
                            measurement_units=regional_context.get('measurement_units', 'metric'),
                            food_culture_notes=regional_context.get('food_culture_notes', '–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞—è —Ä—É—Å—Å–∫–∞—è –∫—É—Ö–Ω—è'),
                            seasonal_products=regional_context.get('seasonal_products', {})
                        )
                    else:
                        regional_context_obj = regional_context
                    
                    prompt = prompt_builder.build_food_analysis_prompt(
                        user_language=user_language,
                        regional_context=regional_context_obj,
                        user_profile=user_profile or {},
                        motivation_level="standard"
                    )
                    response = await provider.generate_with_retry(prompt, image_data)
                    
                    if response.success:
                        logger.info(f"‚úÖ Fallback successful with {provider_key}")
                        return response
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Fallback attempt failed with {tier.value}: {e}")
                continue
        
        # –í—Å–µ fallback –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏
        logger.error("‚ùå All fallback attempts failed")
        return ModelResponse(
            content="",
            model_used="fallback_failed",
            provider="none",
            tokens_used=0,
            cost=0.0,
            response_time=0.0,
            success=False,
            error_message="All fallback options failed"
        )
    
    async def _try_fallback_recipes(self,
                                  image_data: bytes,
                                  user_language: str,
                                  user_context: Dict[str, Any],
                                  regional_context: Dict[str, Any]) -> ModelResponse:
        """–ü–æ–ø—ã—Ç–∫–∞ fallback –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ—Ü–µ–ø—Ç–æ–≤"""
        
        fallback_order = [ModelTier.PREMIUM, ModelTier.STANDARD, ModelTier.BUDGET]
        
        for tier in fallback_order:
            try:
                config = get_model_config(TaskType.RECIPE_GENERATION, tier)
                provider_key = f"{TaskType.RECIPE_GENERATION.value}_{tier.value}_{config.provider}"
                
                if provider_key in self.providers:
                    logger.info(f"üîÑ Trying fallback with {provider_key}")
                    provider = self.providers[provider_key]
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º PromptBuilder –∏ –¥–ª—è fallback —Ä–µ—Ü–µ–ø—Ç–æ–≤
                    from ...prompts.base.prompt_builder import PromptBuilder
                    from ....modules.location.models import RegionalContext
                    
                    prompt_builder = PromptBuilder()
                    
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º regional_context –≤ –æ–±—ä–µ–∫—Ç RegionalContext –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    if regional_context and not isinstance(regional_context, RegionalContext):
                        from ....modules.location.models import RegionalContext
                        regional_context_obj = RegionalContext(
                            region_code=regional_context.get('region_code', 'RU'),
                            cuisine_types=regional_context.get('cuisine_types', ['—Ä—É—Å—Å–∫–∞—è']),
                            common_products=regional_context.get('common_products', ['–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å', '–∫–∞–ø—É—Å—Ç–∞', '–º–æ—Ä–∫–æ–≤—å']),
                            cooking_methods=regional_context.get('cooking_methods', ['–≤–∞—Ä–∫–∞', '–∂–∞—Ä–∫–∞', '—Ç—É—à–µ–Ω–∏–µ']),
                            measurement_units=regional_context.get('measurement_units', 'metric'),
                            food_culture_notes=regional_context.get('food_culture_notes', '–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∞—è —Ä—É—Å—Å–∫–∞—è –∫—É—Ö–Ω—è'),
                            seasonal_products=regional_context.get('seasonal_products', {})
                        )
                    else:
                        regional_context_obj = regional_context
                    
                    prompt = prompt_builder.build_recipe_generation_prompt(
                        user_language=user_language,
                        regional_context=regional_context_obj,
                        user_profile=user_context or {},
                        recipe_count=3
                    )
                    response = await provider.generate_with_retry(prompt, image_data)
                    
                    if response.success:
                        logger.info(f"‚úÖ Fallback successful with {provider_key}")
                        return response
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Fallback attempt failed with {tier.value}: {e}")
                continue
        
        logger.error("‚ùå All recipe fallback attempts failed")
        return ModelResponse(
            content="",
            model_used="fallback_failed",
            provider="none",
            tokens_used=0,
            cost=0.0,
            response_time=0.0,
            success=False,
            error_message="All recipe fallback options failed"
        )
    
    def _create_basic_food_analysis_prompt(self, user_language: str, regional_context: Dict[str, Any]) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –µ–¥—ã (–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)"""
        
        if user_language == "ru":
            return """
            –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –µ–¥—ã –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∏—Ç–∞–Ω–∏–∏.

            –í–ê–ñ–ù–û: –û—Ç–≤–µ—á–∞–π—Ç–µ –¢–û–õ–¨–ö–û –≤–∞–ª–∏–¥–Ω—ã–º JSON –æ–±—ä–µ–∫—Ç–æ–º –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.

            –í–µ—Ä–Ω–∏—Ç–µ –¢–û–õ–¨–ö–û —ç—Ç–æ—Ç JSON –æ–±—ä–µ–∫—Ç:
            {
                "food_items": [
                    {
                        "name": "—Ä—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞",
                        "weight": "–≤–µ—Å –≤ –≥—Ä–∞–º–º–∞—Ö",
                        "calories": —á–∏—Å–ª–æ_–∫–∞–ª–æ—Ä–∏–π
                    }
                ],
                "total_nutrition": {
                    "calories": –æ–±—â–µ–µ_—á–∏—Å–ª–æ_–∫–∞–ª–æ—Ä–∏–π,
                    "proteins": –≥—Ä–∞–º–º—ã_–±–µ–ª–∫–æ–≤,
                    "fats": –≥—Ä–∞–º–º—ã_–∂–∏—Ä–æ–≤,
                    "carbohydrates": –≥—Ä–∞–º–º—ã_—É–≥–ª–µ–≤–æ–¥–æ–≤
                }
            }
            """
        else:
            return """
            Analyze this food image and provide detailed nutritional information.

            IMPORTANT: Respond with ONLY a valid JSON object, no additional text.

            Return ONLY this JSON object:
            {
                "food_items": [
                    {
                        "name": "specific food name",
                        "weight": "weight in grams",
                        "calories": calorie_number
                    }
                ],
                "total_nutrition": {
                    "calories": total_calorie_number,
                    "proteins": protein_grams,
                    "fats": fat_grams,
                    "carbohydrates": carb_grams
                }
            }
            """
    
    def _create_basic_recipe_generation_prompt(self, user_language: str, regional_context: Dict[str, Any], user_context: Dict[str, Any]) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ—Ü–µ–ø—Ç–æ–≤ (–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)"""
        
        if user_language == "ru":
            return """
            –°–æ–∑–¥–∞–π—Ç–µ —Ä–µ—Ü–µ–ø—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.

            –í–µ—Ä–Ω–∏—Ç–µ –¢–û–õ–¨–ö–û JSON –æ–±—ä–µ–∫—Ç:
            {
                "name": "–Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞",
                "description": "–æ–ø–∏—Å–∞–Ω–∏–µ –±–ª—é–¥–∞",
                "prep_time": "–≤—Ä–µ–º—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏",
                "cook_time": "–≤—Ä–µ–º—è –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è",
                "servings": "–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π",
                "ingredients": ["—Å–ø–∏—Å–æ–∫ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤"],
                "instructions": ["–ø–æ—à–∞–≥–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏"],
                "nutrition": {
                    "calories": –∫–∞–ª–æ—Ä–∏–∏_–Ω–∞_–ø–æ—Ä—Ü–∏—é,
                    "protein": –±–µ–ª–∫–∏_–≤_–≥—Ä–∞–º–º–∞—Ö,
                    "carbs": —É–≥–ª–µ–≤–æ–¥—ã_–≤_–≥—Ä–∞–º–º–∞—Ö,
                    "fat": –∂–∏—Ä—ã_–≤_–≥—Ä–∞–º–º–∞—Ö
                }
            }
            """
        else:
            return """
            Create a recipe based on the provided information.

            Return ONLY a JSON object:
            {
                "name": "recipe name",
                "description": "dish description",
                "prep_time": "preparation time",
                "cook_time": "cooking time",
                "servings": "number of servings",
                "ingredients": ["ingredient list"],
                "instructions": ["step-by-step instructions"],
                "nutrition": {
                    "calories": calories_per_serving,
                    "protein": protein_grams,
                    "carbs": carbs_grams,
                    "fat": fat_grams
                }
            }
            """
    
    async def health_check(self) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –≤—Å–µ—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤"""
        logger.info("üè• Running health check for all providers...")
        
        health_results = {
            "overall_healthy": True,
            "providers": {},
            "total_providers": len(self.providers),
            "healthy_providers": 0,
            "unhealthy_providers": 0
        }
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä
        for provider_key, provider in self.providers.items():
            try:
                provider_health = await provider.health_check()
                health_results["providers"][provider_key] = provider_health
                
                if provider_health["healthy"]:
                    health_results["healthy_providers"] += 1
                else:
                    health_results["unhealthy_providers"] += 1
                    health_results["overall_healthy"] = False
                    
            except Exception as e:
                logger.error(f"‚ùå Health check failed for {provider_key}: {e}")
                health_results["providers"][provider_key] = {
                    "healthy": False,
                    "error": str(e)
                }
                health_results["unhealthy_providers"] += 1
                health_results["overall_healthy"] = False
        
        logger.info(f"üè• Health check completed: {health_results['healthy_providers']}/{health_results['total_providers']} providers healthy")
        
        return health_results
    
    def get_available_providers(self) -> Dict[str, Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞—Ö"""
        providers_info = {}
        
        for provider_key, provider in self.providers.items():
            providers_info[provider_key] = provider.get_provider_info()
        
        return providers_info
    
    def is_initialized(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""
        return self.initialized and len(self.providers) > 0