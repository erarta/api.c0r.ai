"""
Telegram Bot Handler for Nutrition Onboarding.
Manages the questionnaire flow and preference collection in Telegram.
"""
from aiogram import types, Bot
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from loguru import logger
import os
import httpx
from typing import Dict, Any, Optional

from common.supabase_client import get_user_by_telegram_id
from shared.auth import get_auth_headers
from i18n.i18n import i18n


API_PUBLIC_URL = os.getenv("API_PUBLIC_URL", "http://api_public:8020")
WEBAPP_URL = os.getenv("WEBAPP_URL", "https://your-app.com")


async def handle_create_food_plan_request(callback: types.CallbackQuery):
    """
    Handle 'Create Food Plan' button press.
    First checks if user has completed onboarding, if not - starts questionnaire.
    """
    try:
        telegram_user_id = callback.from_user.id
        await callback.answer()

        # Get user from database
        user = await get_user_by_telegram_id(telegram_user_id)
        if not user:
            await callback.message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            return

        user_language = user.get("language", "ru")

        # Check if user has completed nutrition onboarding
        onboarding_status = await check_user_onboarding_status(user["id"])

        if not onboarding_status["has_profile"]:
            # User needs onboarding - start questionnaire flow
            await start_nutrition_onboarding(callback, user, user_language)
        else:
            # User has profile - proceed with meal plan generation
            await proceed_to_meal_plan_generation(callback, user, user_language, onboarding_status)

    except Exception as e:
        logger.error(f"Error handling create food plan request: {e}")
        await callback.message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")


async def start_nutrition_onboarding(callback: types.CallbackQuery, user: Dict[str, Any], language: str):
    """Start the nutrition onboarding process"""

    # Get questionnaire summary
    questionnaire_info = await get_questionnaire_summary(user["id"])

    if not questionnaire_info:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–ø—Ä–æ—Å–Ω–∏–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return

    # Create welcome message
    welcome_text = f"""üß¨ **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–∏—Ç–∞–Ω–∏–µ!**

–ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –∏–¥–µ–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è –∏–º–µ–Ω–Ω–æ –¥–ª—è –≤–∞—Å, –¥–∞–≤–∞–π—Ç–µ —É–∑–Ω–∞–µ–º –æ –≤–∞—à–∏—Ö –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è—Ö.

üìã **–ß—Ç–æ –≤–∞—Å –∂–¥–µ—Ç:**
‚Ä¢ {questionnaire_info['total_steps']} —à–∞–≥–æ–≤
‚Ä¢ ~{questionnaire_info['estimated_time']}
‚Ä¢ –í–æ–ø—Ä–æ—Å—ã –æ –≤–∞—à–∏—Ö —Ü–µ–ª—è—Ö, –≤–∫—É—Å–∞—Ö –∏ –æ–±—Ä–∞–∑–µ –∂–∏–∑–Ω–∏

üéØ **–ß—Ç–æ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ:**
‚úÖ –ü–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è –ø–æ–¥ –≤–∞—à–∏ –≤–∫—É—Å—ã
‚úÖ –£—á–µ—Ç –≤—Å–µ—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –∏ –∞–ª–ª–µ—Ä–≥–∏–π
‚úÖ –†–µ—Ü–µ–ø—Ç—ã –ø–æ –≤–∞—à–µ–º—É –≤—Ä–µ–º–µ–Ω–∏ –≥–æ—Ç–æ–≤–∫–∏
‚úÖ –†–µ–∂–∏–º –ø–æ–¥ –≤–∞—à –≥—Ä–∞—Ñ–∏–∫
‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ–¥ –≤–∞—à–∏ —Ü–µ–ª–∏

–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—é?"""

    # Create inline keyboard
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    # Button to start questionnaire in WebApp
    start_questionnaire_btn = InlineKeyboardButton(
        text="üöÄ –ù–∞—á–∞—Ç—å –æ–ø—Ä–æ—Å",
        web_app=WebAppInfo(url=f"{WEBAPP_URL}/nutrition-onboarding")
    )

    # Button for quick setup (basic questions)
    quick_setup_btn = InlineKeyboardButton(
        text="‚ö° –ë—ã—Å—Ç—Ä–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞",
        callback_data="nutrition:quick_setup"
    )

    # Button to learn more
    learn_more_btn = InlineKeyboardButton(
        text="‚ÑπÔ∏è –ü–æ–¥—Ä–æ–±–Ω–µ–µ",
        callback_data="nutrition:learn_more"
    )

    # Button to skip (use basic plan)
    skip_btn = InlineKeyboardButton(
        text="‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        callback_data="nutrition:skip_onboarding"
    )

    keyboard.add(start_questionnaire_btn)
    keyboard.add(quick_setup_btn, learn_more_btn)
    keyboard.add(skip_btn)

    await callback.message.answer(
        welcome_text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


async def handle_quick_setup(callback: types.CallbackQuery):
    """Handle quick setup option - ask only essential questions in Telegram"""

    await callback.answer()

    quick_setup_text = """‚ö° **–ë—ã—Å—Ç—Ä–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞**

–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –ø—Ä—è–º–æ –∑–¥–µ—Å—å:"""

    # Start with the first question
    await ask_quick_question_goal(callback.message, callback.from_user.id)


async def ask_quick_question_goal(message: types.Message, telegram_user_id: int):
    """Ask about primary goal"""

    question_text = """üéØ **–í–æ–ø—Ä–æ—Å 1 –∏–∑ 5**

–ö–∞–∫–∞—è –≤–∞—à–∞ –æ—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å –≤ –ø–∏—Ç–∞–Ω–∏–∏?"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    goals = [
        ("weight_loss", "üîΩ –°–Ω–∏–∂–µ–Ω–∏–µ –≤–µ—Å–∞"),
        ("muscle_gain", "üí™ –ù–∞–±–æ—Ä –º—ã—à–µ—á–Ω–æ–π –º–∞—Å—Å—ã"),
        ("maintenance", "‚öñÔ∏è –ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ —Ñ–æ—Ä–º—ã"),
        ("health_improvement", "‚ù§Ô∏è –£–ª—É—á—à–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è"),
        ("energy_boost", "‚ö° –ë–æ–ª—å—à–µ —ç–Ω–µ—Ä–≥–∏–∏")
    ]

    for goal_id, goal_label in goals:
        keyboard.add(InlineKeyboardButton(
            text=goal_label,
            callback_data=f"quick:goal:{goal_id}"
        ))

    await message.answer(question_text, parse_mode="Markdown", reply_markup=keyboard)


async def handle_quick_goal_selection(callback: types.CallbackQuery):
    """Handle goal selection in quick setup"""

    await callback.answer()

    goal = callback.data.split(":")[-1]

    # Store response temporarily
    await store_quick_response(callback.from_user.id, "primary_goal", goal)

    # Move to next question
    await ask_quick_question_dietary_restrictions(callback.message, callback.from_user.id)


async def ask_quick_question_dietary_restrictions(message: types.Message, telegram_user_id: int):
    """Ask about dietary restrictions"""

    question_text = """üö´ **–í–æ–ø—Ä–æ—Å 2 –∏–∑ 5**

–ï—Å—Ç—å –ª–∏ —É –≤–∞—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –≤ –ø–∏—Ç–∞–Ω–∏–∏?"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    restrictions = [
        ("none", "‚úÖ –ù–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π"),
        ("vegetarian", "ü•¨ –í–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å—Ç–≤–æ"),
        ("vegan", "üå± –í–µ–≥–∞–Ω—Å—Ç–≤–æ"),
        ("gluten_free", "üåæ –ë–µ–∑ –≥–ª—é—Ç–µ–Ω–∞"),
        ("dairy_free", "ü•õ –ë–µ–∑ –º–æ–ª–æ—á–Ω—ã—Ö"),
        ("other", "‚ùì –î—Ä—É–≥–∏–µ")
    ]

    for rest_id, rest_label in restrictions:
        keyboard.add(InlineKeyboardButton(
            text=rest_label,
            callback_data=f"quick:dietary:{rest_id}"
        ))

    await message.edit_text(question_text, parse_mode="Markdown", reply_markup=keyboard)


async def handle_quick_dietary_selection(callback: types.CallbackQuery):
    """Handle dietary restrictions selection"""

    await callback.answer()

    dietary = callback.data.split(":")[-1]
    await store_quick_response(callback.from_user.id, "dietary_type", [dietary])

    await ask_quick_question_cooking_time(callback.message, callback.from_user.id)


async def ask_quick_question_cooking_time(message: types.Message, telegram_user_id: int):
    """Ask about cooking time"""

    question_text = """‚è±Ô∏è **–í–æ–ø—Ä–æ—Å 3 –∏–∑ 5**

–°–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –≥–æ—Ç–æ–≤—ã —Ç—Ä–∞—Ç–∏—Ç—å –Ω–∞ –≥–æ—Ç–æ–≤–∫—É?"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    times = [
        ("minimal", "‚ö° 10-20 –º–∏–Ω—É—Ç (–±—ã—Å—Ç—Ä—ã–µ –±–ª—é–¥–∞)"),
        ("moderate", "‚è∞ 30-45 –º–∏–Ω—É—Ç (—É–º–µ—Ä–µ–Ω–Ω–æ)"),
        ("generous", "üç≥ 1+ —á–∞—Å (–ª—é–±–ª—é –≥–æ—Ç–æ–≤–∏—Ç—å)")
    ]

    for time_id, time_label in times:
        keyboard.add(InlineKeyboardButton(
            text=time_label,
            callback_data=f"quick:cooking_time:{time_id}"
        ))

    await message.edit_text(question_text, parse_mode="Markdown", reply_markup=keyboard)


async def handle_quick_cooking_time_selection(callback: types.CallbackQuery):
    """Handle cooking time selection"""

    await callback.answer()

    cooking_time = callback.data.split(":")[-1]
    await store_quick_response(callback.from_user.id, "cooking_time", cooking_time)

    await ask_quick_question_activity_level(callback.message, callback.from_user.id)


async def ask_quick_question_activity_level(message: types.Message, telegram_user_id: int):
    """Ask about activity level"""

    question_text = """üèÉ‚Äç‚ôÄÔ∏è **–í–æ–ø—Ä–æ—Å 4 –∏–∑ 5**

–ö–∞–∫–æ–π —É –≤–∞—Å —É—Ä–æ–≤–µ–Ω—å —Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏?"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    activities = [
        ("sedentary", "ü™ë –°–∏–¥—è—á–∏–π –æ–±—Ä–∞–∑ –∂–∏–∑–Ω–∏"),
        ("light", "üö∂ –õ–µ–≥–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (1-3 —Ä–∞–∑–∞ –≤ –Ω–µ–¥–µ–ª—é)"),
        ("moderate", "üèÉ –£–º–µ—Ä–µ–Ω–Ω–∞—è (3-5 —Ä–∞–∑ –≤ –Ω–µ–¥–µ–ª—é)"),
        ("high", "üí™ –í—ã—Å–æ–∫–∞—è (6-7 —Ä–∞–∑ –≤ –Ω–µ–¥–µ–ª—é)")
    ]

    for activity_id, activity_label in activities:
        keyboard.add(InlineKeyboardButton(
            text=activity_label,
            callback_data=f"quick:activity:{activity_id}"
        ))

    await message.edit_text(question_text, parse_mode="Markdown", reply_markup=keyboard)


async def handle_quick_activity_selection(callback: types.CallbackQuery):
    """Handle activity level selection"""

    await callback.answer()

    activity = callback.data.split(":")[-1]
    await store_quick_response(callback.from_user.id, "activity_level", activity)

    await ask_quick_question_meal_frequency(callback.message, callback.from_user.id)


async def ask_quick_question_meal_frequency(message: types.Message, telegram_user_id: int):
    """Ask about meal frequency"""

    question_text = """üçΩÔ∏è **–í–æ–ø—Ä–æ—Å 5 –∏–∑ 5**

–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ –µ—Å—Ç—å?"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    frequencies = [
        ("3_meals", "üçΩÔ∏è 3 –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—Ä–∏–µ–º–∞ –ø–∏—â–∏"),
        ("5_small", "ü•Ñ 5-6 –Ω–µ–±–æ–ª—å—à–∏—Ö –ø—Ä–∏–µ–º–æ–≤"),
        ("2_meals", "‚è∞ 2 –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—Ä–∏–µ–º–∞ (–∏–Ω—Ç–µ—Ä–≤–∞–ª—å–Ω–æ–µ –≥–æ–ª–æ–¥–∞–Ω–∏–µ)"),
        ("flexible", "üîÑ –ì–∏–±–∫–∏–π –≥—Ä–∞—Ñ–∏–∫")
    ]

    for freq_id, freq_label in frequencies:
        keyboard.add(InlineKeyboardButton(
            text=freq_label,
            callback_data=f"quick:frequency:{freq_id}"
        ))

    await message.edit_text(question_text, parse_mode="Markdown", reply_markup=keyboard)


async def handle_quick_frequency_selection(callback: types.CallbackQuery):
    """Handle meal frequency selection and complete quick setup"""

    await callback.answer()

    frequency = callback.data.split(":")[-1]
    await store_quick_response(callback.from_user.id, "eating_frequency", frequency)

    # Complete quick setup
    await complete_quick_setup(callback)


async def complete_quick_setup(callback: types.CallbackQuery):
    """Complete quick setup and generate meal plan"""

    try:
        telegram_user_id = callback.from_user.id

        # Get user from database
        user = await get_user_by_telegram_id(telegram_user_id)
        if not user:
            await callback.message.edit_text("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        # Get stored responses
        quick_responses = await get_quick_responses(telegram_user_id)

        if not quick_responses:
            await callback.message.edit_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç—ã.")
            return

        # Submit responses to create basic preferences
        success = await submit_quick_responses(user["id"], quick_responses)

        if success:
            completion_text = """‚úÖ **–ë—ã—Å—Ç—Ä–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!**

–í–∞—à–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è...

üí° *–°–æ–≤–µ—Ç: –ø–æ–∑–∂–µ –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–π—Ç–∏ –ø–æ–ª–Ω—ã–π –æ–ø—Ä–æ—Å –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏.*"""

            keyboard = InlineKeyboardMarkup()
            keyboard.add(InlineKeyboardButton(
                text="üçΩÔ∏è –°–æ–∑–¥–∞—Ç—å –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è",
                callback_data="nutrition:generate_plan"
            ))

            await callback.message.edit_text(
                completion_text,
                parse_mode="Markdown",
                reply_markup=keyboard
            )

            # Clean up temporary storage
            await clear_quick_responses(telegram_user_id)

        else:
            await callback.message.edit_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

    except Exception as e:
        logger.error(f"Error completing quick setup: {e}")
        await callback.message.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")


async def handle_learn_more(callback: types.CallbackQuery):
    """Show more information about personalized nutrition"""

    await callback.answer()

    learn_more_text = """üìö **–ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–∏—Ç–∞–Ω–∏–µ**

üß¨ **Nutrition DNA**
–ú—ã –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–∞—à–∏ –ø–∏—â–µ–≤—ã–µ –ø—Ä–∏–≤—ã—á–∫–∏ –∏ —Å–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π "–≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–π –∫–æ–¥" –ø–∏—Ç–∞–Ω–∏—è - –≤–∞—à Nutrition DNA. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–Ω—è—Ç—å:

‚Ä¢ –í–∞—à –∞—Ä—Ö–µ—Ç–∏–ø –ø–∏—Ç–∞–Ω–∏—è (8 —Ç–∏–ø–æ–≤)
‚Ä¢ –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã (–∫–æ–≥–¥–∞ –≤—ã –µ–¥–∏—Ç–µ)
‚Ä¢ –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã (–∫–∞–∫ –æ–∫—Ä—É–∂–µ–Ω–∏–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –≤—ã–±–æ—Ä –ø–∏—â–∏)
‚Ä¢ –°—Ç—Ä–µ—Å—Å–æ–≤—ã–µ —Ä–µ–∞–∫—Ü–∏–∏ –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø–∏—Ç–∞–Ω–∏–µ

üéØ **–ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞**
–°–∏—Å—Ç–µ–º–∞ –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç:
‚Ä¢ –ú–æ–º–µ–Ω—Ç—ã —Ä–∏—Å–∫–∞ (–∫–æ–≥–¥–∞ –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ—Ä–≤–∞—Ç—å—Å—è)
‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –ø—Ä–∏–µ–º–æ–≤ –ø–∏—â–∏
‚Ä¢ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞ –≤ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ —Ü–µ–ª–µ–π
‚Ä¢ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å

üìä **–ß—Ç–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è:**
‚úÖ –í–∞—à–∏ –≤–∫—É—Å–æ–≤—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è
‚úÖ –ê–ª–ª–µ—Ä–≥–∏–∏ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
‚úÖ –†–∞–±–æ—á–∏–π –≥—Ä–∞—Ñ–∏–∫ –∏ –æ–±—Ä–∞–∑ –∂–∏–∑–Ω–∏
‚úÖ –ö—É–ª–∏–Ω–∞—Ä–Ω—ã–µ –Ω–∞–≤—ã–∫–∏
‚úÖ –í—Ä–µ–º—è –Ω–∞ –≥–æ—Ç–æ–≤–∫—É
‚úÖ –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–∏–≤—ã—á–∫–∏
‚úÖ –¶–µ–ª–∏ –∏ –º–æ—Ç–∏–≤–∞—Ü–∏—è

–ì–æ—Ç–æ–≤—ã —Å–æ–∑–¥–∞—Ç—å —Å–≤–æ–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω?"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton(
        text="üöÄ –ù–∞—á–∞—Ç—å –ø–æ–ª–Ω—ã–π –æ–ø—Ä–æ—Å",
        web_app=WebAppInfo(url=f"{WEBAPP_URL}/nutrition-onboarding")
    ))
    keyboard.add(InlineKeyboardButton(
        text="‚ö° –ë—ã—Å—Ç—Ä–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞",
        callback_data="nutrition:quick_setup"
    ))
    keyboard.add(InlineKeyboardButton(
        text="‚óÄÔ∏è –ù–∞–∑–∞–¥",
        callback_data="nutrition:back_to_welcome"
    ))

    await callback.message.edit_text(
        learn_more_text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


async def handle_skip_onboarding(callback: types.CallbackQuery):
    """Handle skip onboarding - create basic plan"""

    await callback.answer()

    skip_text = """‚è≠Ô∏è **–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—é**

–í—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –±–∞–∑–æ–≤—ã–π –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è –±–µ–∑ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏, –Ω–æ –æ–Ω –±—É–¥–µ—Ç –º–µ–Ω–µ–µ —Ç–æ—á–Ω—ã–º.

**–ë–∞–∑–æ–≤—ã–π –ø–ª–∞–Ω –≤–∫–ª—é—á–∞–µ—Ç:**
‚úÖ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–¥–æ—Ä–æ–≤—ã–µ —Ä–µ—Ü–µ–ø—Ç—ã
‚úÖ –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–∏—Ç–∞–Ω–∏–µ
‚úÖ –û—Å–Ω–æ–≤–Ω—ã–µ –º–∞–∫—Ä–æ–Ω—É—Ç—Ä–∏–µ–Ω—Ç—ã

**–ß—Ç–æ –≤—ã —É–ø—É—Å—Ç–∏—Ç–µ:**
‚ùå –£—á–µ—Ç –≤–∞—à–∏—Ö –≤–∫—É—Å–æ–≤
‚ùå –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ –≥—Ä–∞—Ñ–∏–∫
‚ùå –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚ùå –ü—Ä–æ–≥–Ω–æ–∑—ã –ø–æ–≤–µ–¥–µ–Ω–∏—è

–£–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å?"""

    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton(
        text="‚úÖ –î–∞, —Å–æ–∑–¥–∞—Ç—å –±–∞–∑–æ–≤—ã–π –ø–ª–∞–Ω",
        callback_data="nutrition:create_basic_plan"
    ))
    keyboard.add(InlineKeyboardButton(
        text="üöÄ –ù–µ—Ç, –ø—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å",
        callback_data="nutrition:back_to_welcome"
    ))

    await callback.message.edit_text(
        skip_text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


async def handle_create_basic_plan(callback: types.CallbackQuery):
    """Create basic meal plan without personalization"""

    await callback.answer()

    try:
        telegram_user_id = callback.from_user.id
        user = await get_user_by_telegram_id(telegram_user_id)

        if not user:
            await callback.message.edit_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        # Use the existing food plan generation
        from ..food_plan import start_food_plan_generation

        # Create a mock callback for the existing function
        mock_callback = types.CallbackQuery(
            id=callback.id,
            from_user=callback.from_user,
            message=callback.message,
            data="create_food_plan"
        )

        await start_food_plan_generation(mock_callback)

    except Exception as e:
        logger.error(f"Error creating basic plan: {e}")
        await callback.message.edit_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")


# Helper functions

async def check_user_onboarding_status(user_id: str) -> Dict[str, Any]:
    """Check if user has completed nutrition onboarding"""

    try:
        url = f"{API_PUBLIC_URL}/nutrition-onboarding/check-profile-internal"
        payload = {"user_id": user_id}
        headers = get_auth_headers()

        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.post(url, json=payload, headers=headers)

        if resp.status_code == 200:
            return resp.json()
        else:
            logger.error(f"Failed to check onboarding status: {resp.status_code}")
            return {"has_profile": False, "needs_onboarding": True}

    except Exception as e:
        logger.error(f"Error checking onboarding status: {e}")
        return {"has_profile": False, "needs_onboarding": True}


async def get_questionnaire_summary(user_id: str) -> Optional[Dict[str, Any]]:
    """Get questionnaire summary"""

    try:
        url = f"{API_PUBLIC_URL}/nutrition-onboarding/questionnaire-summary"
        headers = get_auth_headers()
        headers["X-User-ID"] = user_id  # Add user ID to headers

        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.get(url, headers=headers)

        if resp.status_code == 200:
            return resp.json()
        else:
            logger.error(f"Failed to get questionnaire summary: {resp.status_code}")
            return None

    except Exception as e:
        logger.error(f"Error getting questionnaire summary: {e}")
        return None


async def proceed_to_meal_plan_generation(callback: types.CallbackQuery, user: Dict[str, Any], language: str, onboarding_status: Dict[str, Any]):
    """Proceed with meal plan generation for user with completed profile"""

    preferences_summary = onboarding_status.get("preferences_summary", "")

    welcome_back_text = f"""‚úÖ **–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å –≥–æ—Ç–æ–≤!**

{preferences_summary}

–°–æ–∑–¥–∞—é –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è –Ω–∞ 3 –¥–Ω—è..."""

    await callback.message.edit_text(welcome_back_text, parse_mode="Markdown")

    # Use the existing enhanced food plan generation
    from ..food_plan import start_food_plan_generation
    await start_food_plan_generation(callback)


# Quick setup temporary storage functions (in production, use Redis or database)
_quick_responses_storage = {}

async def store_quick_response(telegram_user_id: int, question_id: str, value: Any):
    """Store quick response temporarily"""
    if telegram_user_id not in _quick_responses_storage:
        _quick_responses_storage[telegram_user_id] = {}
    _quick_responses_storage[telegram_user_id][question_id] = value


async def get_quick_responses(telegram_user_id: int) -> Dict[str, Any]:
    """Get stored quick responses"""
    return _quick_responses_storage.get(telegram_user_id, {})


async def clear_quick_responses(telegram_user_id: int):
    """Clear stored quick responses"""
    if telegram_user_id in _quick_responses_storage:
        del _quick_responses_storage[telegram_user_id]


async def submit_quick_responses(user_id: str, responses: Dict[str, Any]) -> bool:
    """Submit quick setup responses to API"""

    try:
        # Convert responses to API format
        response_list = []
        for question_id, value in responses.items():
            response_list.append({
                "question_id": question_id,
                "value": value,
                "timestamp": datetime.utcnow().isoformat()
            })

        url = f"{API_PUBLIC_URL}/nutrition-onboarding/responses"
        payload = {"responses": response_list}
        headers = get_auth_headers()
        headers["X-User-ID"] = user_id

        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.post(url, json=payload, headers=headers)

        return resp.status_code == 200

    except Exception as e:
        logger.error(f"Error submitting quick responses: {e}")
        return False